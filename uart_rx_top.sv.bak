//------------------------------------------------------------------------------
// uart_echo_top_with_leds.sv
//------------------------------------------------------------------------------
// Echo‐back top level, plus drive 8 LEDs with the last received byte.
//------------------------------------------------------------------------------

module uart_rx_top (
  input  logic       clk,        // 50 MHz system clock
  // UART RX side
  input  logic       serial_rx,  // FT232RL TXD → FPGA RXD
  input  logic       dtr_n,      // FT232RL DTR (active‐low enable for RX)
  // LEDs: map each bit of the received byte
  output logic [7:0] leds,
  output logic serial_rx_out
);

  //––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
  // 1) UARTRX instance
  //––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
  logic [7:0] rx_data;
  logic       rx_valid;

  uart_rxv2 #(
    .CLK_FREQ(50_000_000),
    .BAUD    (115200)
  ) u_rx (
    .clk        (clk),
    .serial_rx  (serial_rx),
    .data_out   (rx_data),
    .data_valid (rx_valid)
  );
  
  // Drive the LEDs with the last received byte
  // (you could gate this with rx_valid if you only want
  // to update on new bytes, but a straight assign works too)
  assign leds = rx_data;
  assign serial_rx_out = serial_rx;


endmodule
